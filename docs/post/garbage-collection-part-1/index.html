<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf-8" />

  
  <title>Garbage Collection - Part 1</title>

  
  





  
  <meta name="author" content="Muhammad Umer Azad" />
  <meta name="description" content="TL;DR Stop reading if you&amp;rsquo;ve a computer with infinite memory.
In this series of blog posts, I&amp;rsquo;ll go over some well known garbage collection techniques and analyze the tradeoffs involved from the system design perspective. All the ideas are taken from existing literature and I am not making any claims of original work. Garbage collection is a subject that is very close to my heart, and by writing about it I hope to improve my own understanding of modern language runtimes." />

  
  
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@umerazad" />
    <meta name="twitter:title" content="Garbage Collection - Part 1" />
    <meta name="twitter:description" content="TL;DR Stop reading if you&amp;rsquo;ve a computer with infinite memory.
In this series of blog posts, I&amp;rsquo;ll go over some well known garbage collection techniques and analyze the tradeoffs involved from the system design perspective. All the ideas are taken from existing literature and I am not making any claims of original work. Garbage collection is a subject that is very close to my heart, and by writing about it I hope to improve my own understanding of modern language runtimes." />
    <meta name="twitter:image" content="http://lazymonad.com/img/avatar.jpg" />
  

  
  <meta property="og:type" content="article" />
  <meta property="og:title" content="Garbage Collection - Part 1" />
  <meta property="og:description" content="TL;DR Stop reading if you&amp;rsquo;ve a computer with infinite memory.
In this series of blog posts, I&amp;rsquo;ll go over some well known garbage collection techniques and analyze the tradeoffs involved from the system design perspective. All the ideas are taken from existing literature and I am not making any claims of original work. Garbage collection is a subject that is very close to my heart, and by writing about it I hope to improve my own understanding of modern language runtimes." />
  <meta property="og:url" content="http://lazymonad.com/post/garbage-collection-part-1/" />
  <meta property="og:image" content="http://lazymonad.com/img/avatar.jpg" />




<meta name="generator" content="Hugo 0.31.1" />


<link rel="canonical" href="http://lazymonad.com/post/garbage-collection-part-1/" />
<link rel="alternative" href="http://lazymonad.com/index.xml" title="Lazy Monad" type="application/atom+xml" />


<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="format-detection" content="telephone=no,email=no,adress=no" />
<meta http-equiv="Cache-Control" content="no-transform" />


<meta name="robots" content="index,follow" />
<meta name="referrer" content="origin-when-cross-origin" />







<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="Lazy Monad" />
<meta name="msapplication-tooltip" content="Lazy Monad" />
<meta name='msapplication-navbutton-color' content="#5fbf5e" />
<meta name="msapplication-TileColor" content="#5fbf5e" />
<meta name="msapplication-TileImage" content="/img/tile-image-windows.png" />
<link rel="icon" href="http://lazymonad.com/img/favicon.ico" />
<link rel="icon" type="image/png" sizes="16x16" href="http://lazymonad.com/img/favicon-16x16.png" />
<link rel="icon" type="image/png" sizes="32x32" href="http://lazymonad.com/img/favicon-32x32.png" />
<link rel="icon" sizes="192x192" href="http://lazymonad.com/img/touch-icon-android.png" />
<link rel="apple-touch-icon" href="http://lazymonad.com/img/touch-icon-apple.png" />
<link rel="mask-icon" href="http://lazymonad.com/img/safari-pinned-tab.svg" color="#5fbf5e" />



<link rel="stylesheet" href="//cdn.bootcss.com/video.js/6.2.8/alt/video-js-cdn.min.css" />

<link rel="stylesheet" href="http://lazymonad.com/css/bundle.css" />


  
  <!--[if lt IE 9]>
    <script src="//cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <script src="//cdn.bootcss.com/video.js/6.2.8/ie8/videojs-ie8.min.js"></script>
  <![endif]-->

<!--[if lte IE 11]>
    <script src="//cdn.bootcss.com/classlist/1.1.20170427/classList.min.js"></script>
  <![endif]-->


<script src="//cdn.bootcss.com/object-fit-images/3.2.3/ofi.min.js"></script>


<script src="//cdn.bootcss.com/smooth-scroll/12.1.4/js/smooth-scroll.polyfills.min.js"></script>


</head>
  <body>
    
    <div class="suspension">
      <a title="Go to top" class="to-top is-hide"><span class="icon icon-up"></span></a>
      
        
      
    </div>
    
    
  <header class="site-header">
  <img class="avatar" src="http://lazymonad.com/img/avatar.jpg" alt="Avatar">
  
  <h2 class="title">Lazy Monad</h2>
  
  <p class="subtitle"></p>
  <button class="menu-toggle" type="button">
    <span class="icon icon-menu"></span>
  </button>
  <nav class="site-menu collapsed">
    <h2 class="offscreen">Main Menu</h2>
    <ul class="menu-list">
      
      
      
      
        <li class="menu-item
            
            
            
              is-active
            ">
            <a href="http://lazymonad.com/">Home</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="http://lazymonad.com/tags/">Tags</a>
          </li>
      
        <li class="menu-item
            
            
            ">
            <a href="http://lazymonad.com/about/">About</a>
          </li>
      
    </ul>
  </nav>
  <nav class="social-menu collapsed">
    <h2 class="offscreen">Social Networks</h2>
    <ul class="social-list">

      
      <li class="social-item">
        <a href="mailto:umer@fastmail.com" title="Email"><span class="icon icon-email"></span></a>
      </li>

      
      <li class="social-item">
        <a href="//github.com/umerazad" title="GitHub"><span class="icon icon-github"></span></a>
      </li>

      <li class="social-item">
        <a href="//twitter.com/umerazad" title="Twitter"><span class="icon icon-twitter"></span></a>
      </li>

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <li class="social-item">
        <a href="//www.linkedin.com/in/umerazad" title="Linkedin"><span class="icon icon-linkedin"></span></a>
      </li>

      

      

      

      <li class="social-item">
        <a href="http://lazymonad.com/index.xml"><span class="icon icon-rss" title="RSS"></span></a>
      </li>

    </ul>
  </nav>
</header>

  <section class="main post-detail">
    <header class="post-header">
      <h1 class="post-title">Garbage Collection - Part 1</h1>
      <p class="post-meta">@Muhammad Umer Azad · Oct 30, 2015 · 7 min read</p>
    </header>
    <article class="post-content">

<h2 id="tl-dr">TL;DR</h2>

<p>Stop reading if you&rsquo;ve a computer with infinite memory.</p>

<p>In this series of blog posts, I&rsquo;ll go over some well known <em>garbage collection</em> techniques and analyze the tradeoffs involved from the system design perspective. All the ideas are taken from existing literature and I am not making any claims of original work. Garbage collection is a subject that is very close to my heart, and by writing about it I hope to improve my own understanding of modern language runtimes.</p>

<p>In this post we&rsquo;ll go over a brief overview of the <em>explicit</em> vs <em>automatic</em> memory management approaches. Then we&rsquo;ll establish the terminology that&rsquo;ll serve as the basis of deeper dive into <em>garbage collection</em> algorithms and techniques as discuseed in future blog posts. I know it sounds boring, but just hang in there and I promise we&rsquo;ll get to the fun stuff in the next post.</p>

<ul>
<li><a href="#memory-management">Memory Management</a>

<ul>
<li><a href="#explicit-memory-management">Explicit Memory Management</a></li>
<li><a href="#automatic-memory-management">Automatic Memory Management</a></li>
<li><a href="#basics-of-automatic-memory-management">Basics Of Automatic Memory Management</a>

<ul>
<li><a href="#dynamic-memory-allocation">Dynamic Memory Allocation</a></li>
<li><a href="#garbage-collector">Garbage Collector</a>

<ul>
<li><a href="#mutator">Mutator</a></li>
<li><a href="#collector">Collector</a></li>
</ul></li>
</ul></li>
<li><a href="#desirable-properties-of-garbage-collection-algorithms">Desirable Properties Of Garbage Collection Algorithms</a></li>
</ul></li>
</ul>

<h1 id="memory-management">Memory Management</h1>

<p>Computer memory is a finite resource. Historically, for any reasonably large software system, memory management was typically one of the leading concerns of its designers. They had the momentous task of picking one of the following options:</p>

<ol>
<li><a href="#explicit-memory-management">Explicit memory management</a></li>
<li><a href="#automatic-memory-management">Automatic memory management</a></li>
</ol>

<p>Let&rsquo;s briefly look at the pros and cons of both approaches.</p>

<h2 id="explicit-memory-management">Explicit Memory Management</h2>

<p><em>Explicit memory management</em> requires programmers to manually <em>free/delete</em> the dynamically allocated memory. Languages, like C/C++, offer almost complete control (even address alignment at times) over the object&rsquo;s lifecycle. For large systems, it requires <em>strict</em> programming discipline to ensure the long term correctness and reliability of the programs. Some common coding pitfalls include:</p>

<ul>
<li>Dangling pointers due to releasing a live object</li>
<li>Memory corruption due to double <em>free</em></li>
<li>Memory leaks due to forgetting to release memory</li>
<li>Higher coupling between components due to modeling of ownership semantics in API signatures</li>
</ul>

<p>There are many established patterns to avoid these pitfalls, but pretty much everything boils down to maintaining strict coding discipline that requires consistently using the correct memory management strategy. This becomes tricky for large programs where third party dependencies/libraries might force a mix of multiple approaches. Memory issues are arguably among the hardest class of bugs to investigate. For example, in case of <em>dangling pointers</em> or <em>double free</em>, the best outcome is the immediate crash of the program but typically it doesn&rsquo;t happen and the program continues to run exhibiting unpredictable behavior. Hence the saying, <em>to err is human - to blame it on a computer is even more so.</em></p>

<p>In this day and age, the biggest problem with the option of <em>explicit memory management</em> is that it <em><strong>exists</strong></em>.</p>

<h1 id="automatic-memory-management">Automatic Memory Management</h1>

<p><em>Automatic memory management</em> is an essential feature of all modern programming languages. It relieves the programmer from the burden of memory management by presenting an illusion of infinite memory. For example, the following java program will never run out of memory even when run with no optimizations (<em>-Djava.compiler=NONE</em>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import</span> java.util.UUID<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String <span style="color:#f92672">[]</span>args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>UUID<span style="color:#f92672">.</span><span style="color:#a6e22e">randomUUID</span><span style="color:#f92672">().</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">()));</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span></code></pre></div>
<p>Other pros include:</p>

<ul>
<li>No dangling pointers.</li>
<li>No double frees</li>
<li>Simpler code</li>
<li>Faster development cycle</li>
</ul>

<p><em>Simpler code</em> is the key win with <em>automatic memory management</em>. In <em>garbage collected</em> languages, the code is more readable and easier to reason about.</p>

<p>Having said that, <em>automatic memory management</em> isn&rsquo;t the silver-bullet. It doesn&rsquo;t guarantee absence of memory leaks (more on that later). It introduces space/time tradeoffs with subtle impacts on a program&rsquo;s runtime. Let&rsquo;s start with basics before getting into subtleties.</p>

<h2 id="basics-of-automatic-memory-management">Basics Of Automatic Memory Management</h2>

<p>An <em>automatic memory management</em> system typically comprises of two <em>almost</em> independent parts:</p>

<ol>
<li>Dynamic memory allocation</li>
<li>Garbage collection</li>
</ol>

<h3 id="dynamic-memory-allocation">Dynamic Memory Allocation</h3>

<p>Dynamic memory allocation involves a <em>heap</em> that serves as a pool of memory that backs all the allocated objects. Heap allocation allows the programmers to allocate objects of variable sizes and then freely pass them around beyond current execution context. All heap allocated objects are accessed through <em>references</em>. A <em>reference</em> typically points to one of the following:</p>

<ul>
<li>Address of the allocated object&rsquo;s memory on the heap.</li>
<li>A <em>handle</em> that in-turn contains the object&rsquo;s memory address on the heap</li>
</ul>

<p><em>Handles</em> offer the advantage of allowing an object to be re-allocated easily by updating the handle&rsquo;s value as opposed to updating all the object&rsquo;s references.</p>

<p>Heap offers APIs to <em>allocate</em> and <em>deallocate</em> the objects. We&rsquo;ll refer to this heap interface as <em>allocator</em>.</p>

<h2 id="garbage-collector">Garbage Collector</h2>

<p><em>Garbage collector</em> is the magic component that makes the illusion of <em>infinite memory</em> possible. It typically consists of two semi-independent components known as <em>mutator</em> and <em>collector</em>.</p>

<h3 id="mutator">Mutator</h3>

<p>Typically, all components of a language runtime that are responsible for executing application code, allocating/de-allocating new objects, and managing execution contexts get categorized as the <em>mutators</em>. Most reasonably large programs have more than one <em>mutator</em> threads. Exact number of <em>mutator</em> threads is generally irrelevant to the garbage collection approaches.</p>

<h3 id="collector">Collector</h3>

<p>The <em>collector</em> actually executes the garbage collection code. It discovers the <em>garbage</em> (read: unreachable) objects and reclaims their storage. In concurrent GCs, there may be more than one <em>collector</em> threads. Exact number of <em>collectors</em> is mostly irrelevant to the approaches that we are going to discuss. Most GCs, offer control over the behavior of <em>collectors</em> through configuration settings (more on that later).</p>

<p>The <em>collector</em> is correct <em><strong>only</strong></em> if it never reclaims <em>live</em> objects. Theoretically, determining <em>liveness</em> of an object might not even be possible (e.g. in systems supporting hot patching) even if we&rsquo;ve the time to <em>scan the world</em>. So, most <em>garbage collectors</em> cheat a bit and treat <em>reachability</em> as <em>liveness</em>. An object is considered <em>reachable</em> if a <em>mutator</em> can reach it by following direct or indirect references of the objects in its execution contexts (local/global variables, stack frames, virtual/physical CPU registers, thread local storage, heap references etc.).</p>

<h2 id="desirable-properties-of-garbage-collection-algorithms">Desirable Properties of Garbage Collection Algorithms</h2>

<p>Just like distributed systems, designing a <em>garbage collection</em> mechanism is an exercise in balancing tradeoffs. Some of the desirable properties of <em>garbage collectors</em> are:</p>

<ul>
<li><strong>Correctness</strong> - A GC must be <em>correct</em> and <em>safe</em>. It must never reclaim <em>live</em> objects. The safety typically comes at the cost of performance or efficiency. There are cases where a GCs performance can be improved by feeding it hints from compiler and other runtime systems. More on that later.</li>
<li><strong>Performance</strong> - Overall time spent by a GC should be as short as possible. Typically a GC&rsquo;s performance is measured in two dimensions - latency and throughput. Both significantly depend on the implementation, workload and runtime environment. GCs are by nature intrusive. They introduce pauses by stopping all <em>mutators</em> while performing garbage accounting. It is clearly desirable for these pauses to be as short and as infrequent as possible. In some systems (i.e. distributed lease/transaction coordinators etc.), long pauses could trigger failures resulting in system downtime. Having said that, measuring <em>pause time</em> alone isn&rsquo;t particularly useful in itself. A GC that has no pauses and not <em>garbage reclaiming throughput</em> wouldn&rsquo;t be very useful. Ideally, a GC should reclaim <em>all</em> the garbage in the heap. However, this isn&rsquo;t always possible or even desirable (say for large heaps). For performance reasons, it may be desirable not to collect the whole heap at every <em>collector cycle</em>. Generational garbage collectors (used in Java/.NET etc.) segregate objects by their age into two or more regions called <em>generations</em>. By concentrating effort on the youngest generation, generational collectors can both improve total collection time and reduce the average <em>pause time</em> for individual collections. More on that later.</li>
<li><strong>Space Overhead</strong> - The goal of <em>automatic memory management</em> is the safe and efficient use of space. Memory managers, both <em>explicit</em> and <em>automatic</em>, impose space overheads on the system. Some GCs may impose per-object space overhead (e.g. reference counts); others may be able to piggy back on an object&rsquo;s existing layout (e.g, a dirty bit). <em>Collectors</em> also have space overhead as they are actually doing the garbage accounting. The standard space-vs-time tradeoff applies to all algorithms and GCs are no exception.</li>
</ul>

<p>GC algorithms are complex and juggle way too many tradeoffs. There are cases where programming language semantics can aid a GC&rsquo;s performance. For example, functional languages like ML/Scala, distinguish mutable data from immutable - and GC implementations can leverage this information to improve performance. In the next post, we&rsquo;ll go over the four broad categories of GC algorithms and do a deep dive into one of them. Stay tuned.</p>
</article>
    <footer class="post-footer">
      
      <ul class="post-tags">
        
          <li><a href="http://lazymonad.com/tags/system-design"><span class="tag">System Design</span></a></li>
        
          <li><a href="http://lazymonad.com/tags/garbage-collection"><span class="tag">Garbage Collection</span></a></li>
        
          <li><a href="http://lazymonad.com/tags/memory-management"><span class="tag">Memory Management</span></a></li>
        
          <li><a href="http://lazymonad.com/tags/language-runtimes"><span class="tag">Language Runtimes</span></a></li>
        
      </ul>
      
      <p class="post-copyright">
        © This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. See: https://creativecommons.org/licenses/by-nc/4.0/legalcode.This post was published <strong>790</strong> days ago, its contents might be out of date or inaccurate. 
      </p>
    </footer>
    
      
    
  </section>
  <footer class="site-footer">
  <p>© 2017 Lazy Monad</p>
  <p>Powered by <a href="https://gohugo.io/" target="_blank">Hugo</a> with theme <a href="https://github.com/laozhu/hugo-nuo" target="_blank">Nuo</a>.</p>
  
</footer>



<script async src="//cdn.bootcss.com/video.js/6.2.8/alt/video.novtt.min.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$'], ['\[','\]']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
      extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
  });
</script>
<script type="text/x-mathjax-config">
  // Fix <code> tags after MathJax finishes running. This is a
  // hack to overcome a shortcoming of Markdown. Discussion at
  // https://github.com/mojombo/jekyll/issues/199
  MathJax.Hub.Queue(() => {
    MathJax.Hub.getAllJax().map(v => v.SourceElement().parentNode.className += ' has-jax');
  });
</script>

<script src="http://lazymonad.com/js/bundle.js"></script>




  </body>
</html>
